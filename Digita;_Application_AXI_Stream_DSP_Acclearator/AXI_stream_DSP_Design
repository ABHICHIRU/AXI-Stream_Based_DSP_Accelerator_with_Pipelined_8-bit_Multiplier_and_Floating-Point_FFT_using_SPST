`timescale 1ns/1ps
module fft8_f32_stream (
    input  wire        clk,
    input  wire        rst_n,

    // Input stream (1 complex sample per beat)
    input  wire        s_valid,
    output wire        s_ready,
    input  wire [31:0] s_real,
    input  wire [31:0] s_imag,

    // Output stream (1 complex bin per beat, Y0..Y7)
    output reg         m_valid,
    input  wire        m_ready,
    output reg  [31:0] m_real,
    output reg  [31:0] m_imag
);
    localparam [31:0] FP_P0    = 32'h00000000; // +0.0
    localparam [31:0] FP_P1    = 32'h3F800000; // +1.0
    localparam [31:0] FP_M1    = 32'hBF800000; // -1.0
    localparam [31:0] FP_P0707 = 32'h3F3504F3; // +0.70710678
    localparam [31:0] FP_M0707 = 32'hBF3504F3; // -0.70710678
    localparam [31:0] TW_R0 = 32'h3F800000; //  1.0
    localparam [31:0] TW_I0 = 32'h00000000;
    localparam [31:0] TW_R1 = 32'h3F3504F3; // +0.707 - j0.707
    localparam [31:0] TW_I1 = 32'hBF3504F3;
    localparam [31:0] TW_R2 = 32'h00000000; //  0 - j1
    localparam [31:0] TW_I2 = 32'hBF800000;
    localparam [31:0] TW_R3 = 32'hBF3504F3; // -0.707 - j0.707
    localparam [31:0] TW_I3 = 32'hBF3504F3;
    function [31:0] fneg32;
        input [31:0] x;
        begin fneg32 = {~x[31], x[30:0]}; end
    endfunction

    function [31:0] fadd32;
        input [31:0] a, b;
        reg sa,sb,sr;
        reg [7:0] ea,eb,er;
        reg [23:0] ma,mb;
        reg [24:0] s,d;
        reg [23:0] shv;
        integer sh, i;
        reg [24:0] d_reg;
        reg [7:0] er_reg;
        begin
            sa = a[31]; ea = a[30:23]; ma = (ea==8'd0) ? 24'd0 : {1'b1, a[22:0]};
            sb = b[31]; eb = b[30:23]; mb = (eb==8'd0) ? 24'd0 : {1'b1, b[22:0]};

            // align exponents: make 'a' the larger exponent
            if (eb > ea) begin
                // swap a <-> b
                sr = sb; er = eb;
                sh = eb - ea;
                if (sh >= 24) shv = 24'd0; else shv = ma >> sh;
                ma = mb; mb = shv;
            end else begin
                sr = sa; er = ea;
                sh = ea - eb;
                if (sh >= 24) shv = 24'd0; else shv = mb >> sh;
                mb = shv;
            end

            if (sa == sb) begin
                s = {1'b0, ma} + {1'b0, mb};
                if (s[24]) begin er = er + 8'd1; s = s >> 1; end
                fadd32 = {sr, er, s[22:0]};
            end else begin
                if (ma >= mb) d = {1'b0, ma} - {1'b0, mb};
                else begin d = {1'b0, mb} - {1'b0, ma}; sr = ~sr; end
                if (d == 25'd0) fadd32 = 32'h00000000;
                else begin
                    d_reg = d;
                    er_reg = er;
                    for (i = 0; i < 24; i = i + 1) begin
                        if (d_reg[23] == 1'b0 && er_reg != 8'd0) begin
                            d_reg = d_reg << 1;
                            er_reg = er_reg - 8'd1;
                        end else begin
                            i = 24; // break loop
                        end
                    end
                    fadd32 = {sr, er_reg, d_reg[22:0]};
                end
            end
        end
    endfunction

    function [31:0] fsub32;
        input [31:0] a, b;
        begin fsub32 = fadd32(a, fneg32(b)); end
    endfunction

    function [31:0] fmul32;
        input [31:0] a, b;
        reg sa, sb, sr;
        reg [7:0] ea, eb, er;
        reg [23:0] ma, mb;
        reg [47:0] prod;
        begin
            sa = a[31]; ea = a[30:23]; ma = (ea==8'd0) ? 24'd0 : {1'b1, a[22:0]};
            sb = b[31]; eb = b[30:23]; mb = (eb==8'd0) ? 24'd0 : {1'b1, b[22:0]};
            sr = sa ^ sb;

            if (ma == 24'd0 || mb == 24'd0) fmul32 = 32'h00000000;
            else begin
                er = ea + eb - 8'd127;
                prod = ma * mb; // 24x24 -> 48 bits
                if (prod[47]) fmul32 = {sr, er+8'd1, prod[46:24]};
                else          fmul32 = {sr, er,     prod[45:23]};
            end
        end
    endfunction

    function [31:0] ffma32;
        input [31:0] a,b,c;
        begin ffma32 = fadd32(fmul32(a,b), c); end
    endfunction
    function [31:0] cadd_r; input [31:0] ax, bx; begin cadd_r = fadd32(ax, bx); end endfunction
    function [31:0] cadd_i; input [31:0] ay, by; begin cadd_i = fadd32(ay, by); end endfunction
    function [31:0] csub_r; input [31:0] ax, bx; begin csub_r = fsub32(ax, bx); end endfunction
    function [31:0] csub_i; input [31:0] ay, by; begin csub_i = fsub32(ay, by); end endfunction
    reg fill_sel;                      
    reg [2:0] wr_idx;
    reg full_A, full_B;
    reg [31:0] xrA [0:7];
    reg [31:0] xiA [0:7];
    reg [31:0] xrB [0:7];
    reg [31:0] xiB [0:7];
    assign s_ready = (fill_sel == 1'b0) ? (~full_A) : (~full_B);

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            fill_sel <= 1'b0;
            wr_idx   <= 3'd0;
            full_A   <= 1'b0;
            full_B   <= 1'b0;
        end else begin
            if (s_valid && s_ready) begin
                if (fill_sel == 1'b0) begin
                    xrA[wr_idx] <= s_real;
                    xiA[wr_idx] <= s_imag;
                end else begin
                    xrB[wr_idx] <= s_real;
                    xiB[wr_idx] <= s_imag;
                end

                if (wr_idx == 3'd7) begin
                    if (fill_sel == 1'b0) full_A <= 1'b1; else full_B <= 1'b1;
                    wr_idx  <= 3'd0;
                    fill_sel<= ~fill_sel;
                end else begin
                    wr_idx <= wr_idx + 3'd1;
                end
            end
        end
    end
endmodule

